



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta http-equiv="x-dns-prefetch-control" content="on">
      <link rel="dns-prefetch" href="//oi-wiki.org">
      <link rel="dns-prefetch" href="//search.oi-wiki.org">
      <link rel="dns-prefetch" href="//api.github.com">
      <link rel="dns-prefetch" href="//www.google-analytics.com">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="WWeiying's Learn-notes">
      
      
        <link rel="canonical" href="https://www.wweiying.top/misc/cdq-divide/">
      
      
        <meta name="author" content="WWeiying">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../favicon.ico">
      <meta name="generator" content="mkdocs-1.2.4, mkdocs-material-4.4.2">
    
    
      
        <title>Cdq divide - WWeiying's Learn-notes</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.6f7cfa25.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../assets/javascripts/modernizr.27508f0e.js"></script>
    
    
      
        <style>@font-face{font-family:'Fira Sans';font-style:normal;font-weight:300;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:italic;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot);src:local('Fira Sans'),local('FiraSans-Italic'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:700;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Mono';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot);src:local('Fira Mono'),local('FiraMono-Normal'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.svg#FiraMono) format('svg')}body,input{font-family:"Fira Sans","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Fira Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/vendor/material-icons/iconfont/material-icons.css">
    
      <link rel="manifest" href="../../manifest.webmanifest">
    
    
      <link rel="stylesheet" href="../../_static/css/extra.css?v=13">
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-124485594-1", "auto")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#_1" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://www.wweiying.top/" title="WWeiying's Learn-notes" class="md-header-nav__button md-logo">
          
            <i class="md-icon">school</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              WWeiying's Learn-notes
            </span>
            <span class="md-header-nav__topic">
              
                Cdq divide
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/WWeiying/Learn-notes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    WWeiying/Learn-notes
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

<nav class="md-tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../.." class="md-tabs__link">
          简介
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://www.wweiying.top/" title="WWeiying's Learn-notes" class="md-nav__button md-logo">
      
        <i class="md-icon">school</i>
      
    </a>
    WWeiying's Learn-notes
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/WWeiying/Learn-notes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    WWeiying/Learn-notes
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      简介
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        简介
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../.." title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/about/" title="关于本项目" class="md-nav__link">
      关于本项目
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/htc/" title="如何参与" class="md-nav__link">
      如何参与
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/format/" title="格式手册" class="md-nav__link">
      格式手册
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/faq/" title="F.A.Q." class="md-nav__link">
      F.A.Q.
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/docker-deploy/" title="用 Docker 部署 OI Wiki" class="md-nav__link">
      用 Docker 部署 OI Wiki
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/mirrors/" title="镜像站列表" class="md-nav__link">
      镜像站列表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../intro/thanks/" title="致谢" class="md-nav__link">
      致谢
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    简介
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    解决和点对有关的问题
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    例题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cdq-1d1d" class="md-nav__link">
    CDQ 分治优化 1D/1D 动态规划的转移
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    转移过程的正确性证明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    例题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    将动态问题转化为静态问题
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    例题
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    拓展阅读
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    参考资料与注释
  </a>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" title="评论" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/WWeiying/Learn-notes/edit/master/docs/misc/cdq-divide.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>Cdq divide</h1>
                
                <p>本页面将介绍 CDQ 分治。</p>
<h2 id="_1">简介<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>CDQ 分治是一种思想而不是具体的算法，与 <a href="../../dp/">动态规划</a> 类似。目前这个思想的拓展十分广泛，依原理与写法的不同，大致分为三类：</p>
<ul>
<li>解决和点对有关的问题。</li>
<li>1D 动态规划的优化与转移。</li>
<li>通过 CDQ 分治，将一些动态问题转化为静态问题。</li>
</ul>
<p>CDQ 分治的思想最早由 IOI2008 金牌得主陈丹琦在高中时整理并总结，它也因此得名。<sup id="fnref:ref1"><a class="footnote-ref" href="#fn:ref1">1</a></sup></p>
<h2 id="_2">解决和点对有关的问题<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>这类问题多数类似于「给定一个长度为 n 的序列，统计有一些特性的点对 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 的数量/找到一对点 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 使得一些函数的值最大」。</p>
<p>CDQ 分治解决这类问题的算法流程如下：</p>
<ol>
<li>
<p>找到这个序列的中点 <span class="arithmatex"><span class="MathJax_Preview">mid</span><script type="math/tex">mid</script></span>；</p>
</li>
<li>
<p>将所有点对 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 划分为 3 类：</p>
<ol>
<li><span class="arithmatex"><span class="MathJax_Preview">1 \leq i \leq mid,1 \leq j \leq mid</span><script type="math/tex">1 \leq i \leq mid,1 \leq j \leq mid</script></span> 的点对；</li>
<li><span class="arithmatex"><span class="MathJax_Preview">1  \leq i \leq mid ,mid+1 \leq j \leq n</span><script type="math/tex">1  \leq i \leq mid ,mid+1 \leq j \leq n</script></span> 的点对；</li>
<li><span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq  i \leq n,mid+1 \leq j \leq n</span><script type="math/tex">mid+1 \leq  i \leq n,mid+1 \leq j \leq n</script></span> 的点对。</li>
</ol>
</li>
<li>
<p>将 <span class="arithmatex"><span class="MathJax_Preview">(1,n)</span><script type="math/tex">(1,n)</script></span> 这个序列拆成两个序列 <span class="arithmatex"><span class="MathJax_Preview">(1,mid)</span><script type="math/tex">(1,mid)</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">(mid+1,n)</span><script type="math/tex">(mid+1,n)</script></span>。此时第一类点对和第三类点对都在这两个序列之中；</p>
</li>
<li>
<p>递归地处理这两类点对；</p>
</li>
<li>
<p>设法处理第二类点对。</p>
</li>
</ol>
<p>可以看到 CDQ 分治的思想就是不断地把点对通过递归的方式分给左右两个区间。</p>
<p>在实际应用时，我们通常使用一个函数 <code>solve(l,r)</code> 处理 <span class="arithmatex"><span class="MathJax_Preview">l \leq i \leq r,l \leq j \leq r</span><script type="math/tex">l \leq i \leq r,l \leq j \leq r</script></span> 的点对。上述算法流程中的递归部分便是通过 <code>solve(l,mid)</code> 与 <code>solve(mid,r)</code> 来实现的。剩下的第二类点对则需要额外设计算法解决。</p>
<h3 id="_3">例题<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<details class="三维偏序" open="open">
<summary>三维偏序</summary>
<p>给定一个序列，每个点有两个属性 <span class="arithmatex"><span class="MathJax_Preview">(a,b)</span><script type="math/tex">(a,b)</script></span>，试求：这个序列里有多少对点对 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 满足 <span class="arithmatex"><span class="MathJax_Preview">i&lt;j,a_{i}&lt;a_{j},b_{i}&lt;b_{j}</span><script type="math/tex">i<j,a_{i}<a_{j},b_{i}<b_{j}</script></span>。</p>
<details class="解题思路">
<summary>解题思路</summary>
<p>三维偏序是 CDQ 分治的经典问题。</p>
<p>题目要求统计序列里点对的个数，那试一下用 CDQ 分治。</p>
<p>假设我们现在写好了 <code>solve(l,r)</code>，并且通过递归搞定了 <code>solve(l,mid)</code> 和 <code>solve(mid+1,r)</code>。现在我们要做的，就是统计满足 <span class="arithmatex"><span class="MathJax_Preview">l \leq i \leq mid</span><script type="math/tex">l \leq i \leq mid</script></span>,<span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq j \leq r</span><script type="math/tex">mid+1 \leq j \leq r</script></span> 的点对 <span class="arithmatex"><span class="MathJax_Preview">(i,j)</span><script type="math/tex">(i,j)</script></span> 中，有多个点对还满足 <span class="arithmatex"><span class="MathJax_Preview">i&lt;j</span><script type="math/tex">i<j</script></span>,<span class="arithmatex"><span class="MathJax_Preview">a_{i}&lt;a_{j}</span><script type="math/tex">a_{i}<a_{j}</script></span>,<span class="arithmatex"><span class="MathJax_Preview">b_{i}&lt;b_{j}</span><script type="math/tex">b_{i}<b_{j}</script></span> 的限制条件。</p>
<p>稍微思考一下就会发现，那个 <span class="arithmatex"><span class="MathJax_Preview">i&lt;j</span><script type="math/tex">i<j</script></span> 的限制条件没啥用了：既然 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 比 <span class="arithmatex"><span class="MathJax_Preview">mid</span><script type="math/tex">mid</script></span> 小，<span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 比 <span class="arithmatex"><span class="MathJax_Preview">mid</span><script type="math/tex">mid</script></span> 大，那 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 肯定比 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 要小。现在还剩下两个限制条件：<span class="arithmatex"><span class="MathJax_Preview">a_{i}&lt;a_{j}</span><script type="math/tex">a_{i}<a_{j}</script></span> 与 <span class="arithmatex"><span class="MathJax_Preview">b_{i}&lt;b_{j}</span><script type="math/tex">b_{i}<b_{j}</script></span>, 根据这个限制条件我们就可以枚举 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>, 求出有多少个满足条件的 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>。</p>
<p>为了方便枚举，我们把 <span class="arithmatex"><span class="MathJax_Preview">(l,mid)</span><script type="math/tex">(l,mid)</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">(mid+1,r)</span><script type="math/tex">(mid+1,r)</script></span> 中的点全部按照 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> 的值从小到大排个序。之后我们依次枚举每一个 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>, 把所有 <span class="arithmatex"><span class="MathJax_Preview">a_{i}&lt;a_{j}</span><script type="math/tex">a_{i}<a_{j}</script></span> 的点 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 全部插入到某种数据结构里（这里我们选择 <a href="../../ds/fenwick/">树状数组</a>）。此时只要查询树状数组里有多少个点的 <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> 值是小于 <span class="arithmatex"><span class="MathJax_Preview">b_{j}</span><script type="math/tex">b_{j}</script></span> 的，我们就求出了对于这个点 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>，有多少个 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 可以合法匹配它了。</p>
<p>当我们插入一个 <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> 值等于 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 的点时，我们就令树状数组的 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 这个位置单点 + 1，而查询树状数组里有多少个点小于 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 的操作实际上就是在求 <a href="../../basic/prefix-sum/">前缀和</a>，只要我们事先对于所有的 <span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> 值做了 <a href="../discrete/">离散化</a>，我们的复杂度就是对的。</p>
<p>对于每一个 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>，我们都需要将所有 <span class="arithmatex"><span class="MathJax_Preview">a_{i}&lt;a_{j}</span><script type="math/tex">a_{i}<a_{j}</script></span> 的点 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 插入树状数组中。由于所有的 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 都已事先按照 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> 值排好序，这样的话只要以双指针的方式在树状数组里插入点，则对树状数组的插入操作就能从 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 次降到 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span> 次。</p>
<p>通过这样一个算法流程，我们就用 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span> 的时间处理完了关于第二类点对的信息了。此时算法的时间复杂度是 <span class="arithmatex"><span class="MathJax_Preview">T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+O(n\log n)=O(n\log^2n)</span><script type="math/tex">T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+O(n\log n)=O(n\log^2n)</script></span>。</p>
</details>
</details>
<hr />
<details class="note" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P3157">CQOI2011动态逆序对</a></summary>
<p>对于序列 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>，它的逆序对数定义为集合 <span class="arithmatex"><span class="MathJax_Preview">\{(i,j)| i&lt;j \wedge a_i &gt; a_j \}</span><script type="math/tex">\{(i,j)| i<j \wedge a_i > a_j \}</script></span> 中的元素个数。</p>
<p>现在给出 <span class="arithmatex"><span class="MathJax_Preview">1\sim n</span><script type="math/tex">1\sim n</script></span> 的一个排列，按照某种顺序依次删除 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。</p>
<details class="示例代码">
<summary>示例代码</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
</details>
</details>
<h2 id="cdq-1d1d">CDQ 分治优化 1D/1D 动态规划的转移<a class="headerlink" href="#cdq-1d1d" title="Permanent link">&para;</a></h2>
<p>1D/1D 动态规划指的是一类特定的 DP 问题，该类题目的特征是 DP 数组是一维的，转移是 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span> 的。如果条件良好的话，有时可以通过 CDQ 分治来把它们的时间复杂度由 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 降至 <span class="arithmatex"><span class="MathJax_Preview">O(n\log^2n)</span><script type="math/tex">O(n\log^2n)</script></span>。</p>
<p>例如，给定一个序列，每个元素有两个属性 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>，<span class="arithmatex"><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span>。我们希望计算一个 DP 式子的值，它的转移方程如下：</p>
<p><span class="arithmatex"><span class="MathJax_Preview">dp_{i}=1+ \max_{j=1}^{i-1}dp_{j}[a_{j}&lt;a_{i}][b_{j}&lt;b_{i}]</span><script type="math/tex">dp_{i}=1+ \max_{j=1}^{i-1}dp_{j}[a_{j}<a_{i}][b_{j}<b_{i}]</script></span></p>
<p>这是一个二维最长上升子序列的 DP 方程，即只有 <span class="arithmatex"><span class="MathJax_Preview">j&lt;i,a_{j}&lt;a_{i}</span><script type="math/tex">j<i,a_{j}<a_{i}</script></span>,<span class="arithmatex"><span class="MathJax_Preview">b_{j}&lt;b_{i}</span><script type="math/tex">b_{j}<b_{i}</script></span> 的点 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 可以更新点 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 的 DP 值。</p>
<p>直接转移显然是 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 的。以下是使用 CDQ 分治优化转移过程的讲解。</p>
<p>我们发现 <span class="arithmatex"><span class="MathJax_Preview">dp_{j}</span><script type="math/tex">dp_{j}</script></span> 转移到 <span class="arithmatex"><span class="MathJax_Preview">dp_{i}</span><script type="math/tex">dp_{i}</script></span> 这种转移关系也是一种点对间的关系，所以我们用类似 CDQ 分治处理点对关系的方式来处理它。</p>
<p>这个转移过程相对来讲比较套路。假设现在正在处理的区间是 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span>，算法流程大致如下：</p>
<ol>
<li>如果 <span class="arithmatex"><span class="MathJax_Preview">l=r</span><script type="math/tex">l=r</script></span>，说明 <span class="arithmatex"><span class="MathJax_Preview">dp_{r}</span><script type="math/tex">dp_{r}</script></span> 值已经被计算好了。直接令 <span class="arithmatex"><span class="MathJax_Preview">dp_{r}++</span><script type="math/tex">dp_{r}++</script></span> 然后返回即可；</li>
<li>递归使用 <code>solve(l,mid)</code>；</li>
<li>处理所有 <span class="arithmatex"><span class="MathJax_Preview">l \leq j \leq mid</span><script type="math/tex">l \leq j \leq mid</script></span>，<span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq i \leq r</span><script type="math/tex">mid+1 \leq i \leq r</script></span> 的转移关系；</li>
<li>递归使用 <code>solve(mid+1,r)</code>。</li>
</ol>
<p>第三步的做法与 CDQ 分治求三维偏序差不多。处理 <span class="arithmatex"><span class="MathJax_Preview">l \leq j \leq mid</span><script type="math/tex">l \leq j \leq mid</script></span>，<span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq i \leq r</span><script type="math/tex">mid+1 \leq i \leq r</script></span> 的转移关系的时候，我们会发现已经不用管 <span class="arithmatex"><span class="MathJax_Preview">j&lt;i</span><script type="math/tex">j<i</script></span> 这个限制条件了。因此，我们依然先将所有的点 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 和点 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 按 <span class="arithmatex"><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> 值进行排序处理，然后用双指针的方式将 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 点插入到树状数组里，最后查一下前缀最大值更新一下 <span class="arithmatex"><span class="MathJax_Preview">dp_{i}</span><script type="math/tex">dp_{i}</script></span> 就可以了。</p>
<h3 id="_4">转移过程的正确性证明<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>该 CDQ 写法和处理点对间关系的 CDQ 写法最大的不同就是处理 <span class="arithmatex"><span class="MathJax_Preview">l \leq j \leq mid</span><script type="math/tex">l \leq j \leq mid</script></span>，<span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq i \leq r</span><script type="math/tex">mid+1 \leq i \leq r</script></span> 的点对这一部分。处理点对间关系的 CDQ 写法中，这一部分放到哪里都是可以的。但是，在用 CDQ 分治优化 DP 的时候，这个流程却必须夹在 <span class="arithmatex"><span class="MathJax_Preview">solve(l,mid)</span><script type="math/tex">solve(l,mid)</script></span>,<span class="arithmatex"><span class="MathJax_Preview">solve(mid+1,r)</span><script type="math/tex">solve(mid+1,r)</script></span> 的中间。原因是 DP 的转移是 <strong>有序的</strong>，它必须满足两个条件，否则就是不对的：</p>
<ol>
<li>
<p>用来计算 <span class="arithmatex"><span class="MathJax_Preview">dp_{i}</span><script type="math/tex">dp_{i}</script></span> 的所有 <span class="arithmatex"><span class="MathJax_Preview">dp_{j}</span><script type="math/tex">dp_{j}</script></span> 值都必须是已经计算完毕的，不能存在“半成品”；</p>
</li>
<li>
<p>用来计算 <span class="arithmatex"><span class="MathJax_Preview">dp_{i}</span><script type="math/tex">dp_{i}</script></span> 的所有 <span class="arithmatex"><span class="MathJax_Preview">dp_{j}</span><script type="math/tex">dp_{j}</script></span> 值都必须能更新到 <span class="arithmatex"><span class="MathJax_Preview">dp_{i}</span><script type="math/tex">dp_{i}</script></span>，不能存在没有更新到的 <span class="arithmatex"><span class="MathJax_Preview">dp_{j}</span><script type="math/tex">dp_{j}</script></span> 值。</p>
</li>
</ol>
<p>上述两个条件可能在 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 暴力的时候是相当容易满足的，但是使用 CDQ 分治后，转移顺序很显然已经乱掉了，所以有必要考察转移的正确性。</p>
<p>CDQ 分治的递归树如下所示。</p>
<p><img alt="CDQ 分治的递归树" src="../images/cdq1.png" /></p>
<p>执行刚才的算法流程的话，以 <span class="arithmatex"><span class="MathJax_Preview">8</span><script type="math/tex">8</script></span> 这个点为例，它的 DP 值是在 <code>solve(1,8)</code>、<code>solve(5,8)</code>、<code>solve(7,8)</code> 这 3 个函数中更新完成的，而三次用来更新它的点分别是 <span class="arithmatex"><span class="MathJax_Preview">(1,4)</span><script type="math/tex">(1,4)</script></span>、<span class="arithmatex"><span class="MathJax_Preview">(5,6)</span><script type="math/tex">(5,6)</script></span>、<span class="arithmatex"><span class="MathJax_Preview">(7,7)</span><script type="math/tex">(7,7)</script></span> 这三个不相交的区间；又以 <span class="arithmatex"><span class="MathJax_Preview">5</span><script type="math/tex">5</script></span> 这个点为例，它的 DP 值是在 <code>solve(1,4)</code> 函数中解决的，更新它的区间是 <span class="arithmatex"><span class="MathJax_Preview">(1,4)</span><script type="math/tex">(1,4)</script></span>。仔细观察就会发现，一个 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 点的 DP 值被更新了 <span class="arithmatex"><span class="MathJax_Preview">\log</span><script type="math/tex">\log</script></span> 次，而且，更新它的区间刚好是 <span class="arithmatex"><span class="MathJax_Preview">(1,i)</span><script type="math/tex">(1,i)</script></span> 在线段树上被拆分出来的 <span class="arithmatex"><span class="MathJax_Preview">\log</span><script type="math/tex">\log</script></span> 个区间。因此，我们的确保证了所有合法的 <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 都更新过点 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>，满足第 2 个条件。</p>
<p>接着分析我们算法的执行流程：</p>
<ol>
<li>第一个结束的函数是 <code>solve(1,1)</code>。此时我们发现 <span class="arithmatex"><span class="MathJax_Preview">dp_{1}</span><script type="math/tex">dp_{1}</script></span> 的值已经计算完毕了；</li>
<li>第一个执行转移过程的函数是 <code>solve(1,2)</code>。此时我们发现 <span class="arithmatex"><span class="MathJax_Preview">dp_{2}</span><script type="math/tex">dp_{2}</script></span> 的值已经被转移好了；</li>
<li>第二个结束的函数是 <code>solve(2,2)</code>。此时我们发现 <span class="arithmatex"><span class="MathJax_Preview">dp_{2}</span><script type="math/tex">dp_{2}</script></span> 的值已经计算完毕了；</li>
<li>接下来 <code>solve(1,2)</code> 结束，<span class="arithmatex"><span class="MathJax_Preview">(1,2)</span><script type="math/tex">(1,2)</script></span> 这段区间的 <span class="arithmatex"><span class="MathJax_Preview">dp</span><script type="math/tex">dp</script></span> 值均被计算好；</li>
<li>下一个执行转移流程的函数是 <code>solve(1,4)</code>。这次转移结束之后我们发现 <span class="arithmatex"><span class="MathJax_Preview">dp_{3}</span><script type="math/tex">dp_{3}</script></span> 的值已经被转移好了；</li>
<li>接下来结束的函数是 <code>solve(3,3)</code>。我们会发现 <span class="arithmatex"><span class="MathJax_Preview">dp_{3}</span><script type="math/tex">dp_{3}</script></span> 的 dp 值被计算好了；</li>
<li>接下来执行的转移是 <code>solve(2,4)</code>。此时 <span class="arithmatex"><span class="MathJax_Preview">dp_{4}</span><script type="math/tex">dp_{4}</script></span> 在 <code>solve(1,4)</code> 中被 <span class="arithmatex"><span class="MathJax_Preview">(1,2)</span><script type="math/tex">(1,2)</script></span> 转移了一次，这次又被 <span class="arithmatex"><span class="MathJax_Preview">(3,3)</span><script type="math/tex">(3,3)</script></span> 转移了，因此 <span class="arithmatex"><span class="MathJax_Preview">dp_{4}</span><script type="math/tex">dp_{4}</script></span> 的值也被转移好了；</li>
<li><code>solve(4,4)</code> 结束，<span class="arithmatex"><span class="MathJax_Preview">dp_{4}</span><script type="math/tex">dp_{4}</script></span> 的值计算完毕；</li>
<li><code>solve(3,4)</code> 结束，<span class="arithmatex"><span class="MathJax_Preview">(3,4)</span><script type="math/tex">(3,4)</script></span> 的值计算完毕；</li>
<li><code>solve(1,4)</code> 结束，<span class="arithmatex"><span class="MathJax_Preview">(1,4)</span><script type="math/tex">(1,4)</script></span> 的值计算完毕。</li>
<li>……</li>
</ol>
<p>通过模拟函数流程，我们发现一件事：每次 <code>solve(l,r)</code> 结束的时候，<span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 区间的 DP 值会被全部计算好。由于我们每一次执行转移函数的时候，<code>solve(l,mid)</code> 已经结束，因此我们每一次执行的转移过程都是合法的，满足第 1 个条件。</p>
<p>在刚才的过程我们发现，如果将 CDQ 分治的递归树看成一颗线段树，那么 CDQ 分治就是这个线段树的 <strong>中序遍历函数</strong>，因此我们相当于按顺序处理了所有的 DP 值，只是转移顺序被拆开了而已，所以算法是正确的。</p>
<h3 id="_5">例题<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<details class="note" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P2487">SDOI2011拦截导弹</a></summary>
<p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。</p>
<p>我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。</p>
<details class="参考代码">
<summary>参考代码</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
</details>
</details>
<h2 id="_6">将动态问题转化为静态问题<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p>前两种情况使用 CDQ 分治的目的是将序列折半之后递归处理点对间的关系，来获得良好的复杂度。不过在本节中，折半的不是一般的序列，而是时间序列。</p>
<p>它适用于一些「需要支持做 xxx 修改然后做 xxx 询问」的数据结构题。该类题目有两个特点：</p>
<ul>
<li>如果把询问 <a href="../offline/">离线</a>，所有操作会按照时间自然地排成一个序列。</li>
<li>每一个修改均与之后的询问操作息息相关。而这样的“修改 - 询问”关系一共会有 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 对。</li>
</ul>
<p>我们可以使用 CDQ 分治对于这个操作序列进行分治，处理修改和询问之间的关系。</p>
<p>与处理点对关系的 CDQ 分治类似，假设正在分治的序列是 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span>, 我们先递归地处理 <span class="arithmatex"><span class="MathJax_Preview">(l,mid)</span><script type="math/tex">(l,mid)</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">(mid,r)</span><script type="math/tex">(mid,r)</script></span> 之间的修改 - 询问关系，再处理所有 <span class="arithmatex"><span class="MathJax_Preview">l \leq i \leq mid</span><script type="math/tex">l \leq i \leq mid</script></span>，<span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq j \leq r</span><script type="math/tex">mid+1 \leq j \leq r</script></span> 的修改 - 询问关系，其中 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 是一个修改，<span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> 是一个询问。</p>
<p>注意，如果各个修改之间是 <strong>独立</strong> 的话，我们无需处理 <span class="arithmatex"><span class="MathJax_Preview">l \leq i \leq mid</span><script type="math/tex">l \leq i \leq mid</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">mid+1 \leq j \leq r</span><script type="math/tex">mid+1 \leq j \leq r</script></span>，以及 <code>solve(l,mid)</code> 和 <code>solve(mid+1,r)</code> 之间的时序关系（比如普通的加减法问题）。但是如果各个修改之间并不独立（比如说赋值操作），做完这个修改后，序列长什么样可能依赖于之前的序列。此时处理所有跨越 mid 的修改 - 询问关系的步骤就必须放在 <code>solve(l,mid)</code> 和 <code>solve(mid+1,r)</code> 之间。理由和 CDQ 分治优化 1D/1D 动态规划的原因是一样的：按照中序遍历序进行分治才能保证每一个修改都是严格按照时间顺序执行的。</p>
<h3 id="_7">例题<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<details class="note" open="open">
<summary>矩形加矩形求和</summary>
<p>维护一个二维平面，然后支持在一个矩形区域内加一个数字，每次询问一个矩形区域的和。</p>
<details class="解题思路">
<summary>解题思路</summary>
<p>对于这个问题的静态版本，即“二维平面里有一堆矩形，我们希望询问一个矩形区域的和”，有一个经典做法叫线段树 + 扫描线。具体的做法是先将每个矩形拆成插入和删除两个操作，接着将每个询问拆成两个前缀和相减的形式，最后离线。然而，原题目是动态的，不能直接使用这种做法。</p>
<p>尝试对其使用 CDQ 分治。我们将所有的询问和修改操作全部离线。这些操作形成了一个序列，并且有 <span class="arithmatex"><span class="MathJax_Preview">O(N^2)</span><script type="math/tex">O(N^2)</script></span> 对修改 - 询问的关系。依然使用 CDQ 分治的一般流程，将所有的关系分成三类，在这一层分治过程当中只处理跨越 <span class="arithmatex"><span class="MathJax_Preview">mid</span><script type="math/tex">mid</script></span> 的修改 - 询问关系，剩下的修改 - 询问关系通过递归的的方式来解决。</p>
<p>我们发现，所有的修改在询问之前就已完成。这时，原问题等价于“平面上有静态的一堆矩形，不停地询问一个矩形区域的和”。</p>
<p>使用一个扫描线在 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span> 的时间内处理好所有跨越 <span class="arithmatex"><span class="MathJax_Preview">mid</span><script type="math/tex">mid</script></span> 的修改 - 询问关系，剩下的事情就是递归地分治左右两侧的修改 - 询问关系了。</p>
<p>在这样实现的 CDQ 分治中，同一个询问被处理了 <span class="arithmatex"><span class="MathJax_Preview">O(\log n)</span><script type="math/tex">O(\log n)</script></span> 次。不过没有关系，因为每次贡献这个询问的修改是互不相交的。全套流程的时间复杂度为 <span class="arithmatex"><span class="MathJax_Preview">T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+ O(n\log n)=O(n\log^2n)</span><script type="math/tex">T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+ O(n\log n)=O(n\log^2n)</script></span>。</p>
<p>观察上述的算法流程，我们发现一开始我们只能解决静态的矩形加矩形求和问题，但只是简单地使用 CDQ 分治后，我们就可以离线地解决一个动态的矩形加矩形求和问题了。将动态问题转化为静态问题的精髓就在于 CDQ 分治每次仅仅处理跨越某一个点的修改和询问关系，这样的话我们就只需要考虑「所有询问都在修改之后」这个简单的问题了。也正是因为这一点，CDQ 分治被称为「动态问题转化为静态问题的工具」。</p>
</details>
</details>
<hr />
<details class="note" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P4690">[Ynoi2016]镜中的昆虫</a></summary>
<p>维护一个长为 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 的序列 <span class="arithmatex"><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span>，有 <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> 次操作。</p>
<ol>
<li>
<p>将区间 <span class="arithmatex"><span class="MathJax_Preview">[l,r]</span><script type="math/tex">[l,r]</script></span> 的值修改为 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>；</p>
</li>
<li>
<p>询问区间 <span class="arithmatex"><span class="MathJax_Preview">[l,r]</span><script type="math/tex">[l,r]</script></span> 出现了多少种不同的数，也就是说同一个数出现多次只算一个。</p>
</li>
</ol>
<details class="解题思路">
<summary>解题思路</summary>
<p>一句话题意：区间赋值区间数颜色。</p>
<p>维护一下每个位置左侧第一个同色点的位置，记为 <span class="arithmatex"><span class="MathJax_Preview">pre_{i}</span><script type="math/tex">pre_{i}</script></span>，此时区间数颜色就被转化为了一个经典的二维数点问题。</p>
<p>通过将连续的一段颜色看成一个点的方式，可以证明 <span class="arithmatex"><span class="MathJax_Preview">pre</span><script type="math/tex">pre</script></span> 的变化量是 <span class="arithmatex"><span class="MathJax_Preview">O(n+m)</span><script type="math/tex">O(n+m)</script></span> 的，即单次操作仅仅引起 <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> 的 <span class="arithmatex"><span class="MathJax_Preview">pre</span><script type="math/tex">pre</script></span> 值变化，那么我们可以用 CDQ 分治来解决动态的单点加矩形求和问题。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">pre</span><script type="math/tex">pre</script></span> 数组的具体变化可以使用 <code>$std::set$</code> 来进行处理。这个用 set 维护连续的区间的技巧也被称之为 <a href="../../ds/odt/">old driver tree</a>。</p>
</details>
<details class="参考代码">
<summary>参考代码</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
</details>
</details>
<hr />
<details class="note" open="open">
<summary><a href="https://www.luogu.com.cn/problem/P3206">[HNOI2010]城市建设</a></summary>
<p>PS 国是一个拥有诸多城市的大国。国王 Louis 为城市的交通建设可谓绞尽脑汁。Louis 可以在某些城市之间修建道路，在不同的城市之间修建道路需要不同的花费。</p>
<p>Louis 希望建造最少的道路使得国内所有的城市连通。但是由于某些因素，城市之间修建道路需要的花费会随着时间而改变。Louis 会不断得到某道路的修建代价改变的消息。他希望每得到一条消息后能立即知道使城市连通的最小花费总和。Louis 决定求助于你来完成这个任务。</p>
<details class="解题思路">
<summary>解题思路</summary>
<p>一句话题意：给定一张图支持动态的修改边权，要求在每次修改边权之后输出这张图的最小生成树的最小代价和。</p>
<p>事实上，有一个线段树分治套 lct 的做法可以解决这个问题，但是这个实现方式的常数过大，可能需要精妙的卡常技巧才可以通过本题，因此不妨考虑 CDQ 分治来解决这个问题。</p>
<p>和一般的 CDQ 分治解决的问题不同，此时使用 CDQ 分治的时候并没有修改和询问的关系来让我们进行分治，因为无法单独考虑“修改一个边对整张图的最小生成树有什么贡献”。传统的 CDQ 分治思路似乎不是很好使。</p>
<p>通过刚才的例题可以发现，一般的 CDQ 分治和线段树有着特殊的联系：我们在 CDQ 分治的过程中其实隐式地建了一棵线段树出来（因为 CDQ 分治的递归树就是一颗线段树）。通常的 CDQ 是考虑线段树左右儿子之间的联系。而对于这道题，我们需要考虑的是父亲和孩子之间的关系；换句话来讲，我们在 <code>$solve(l,r)$</code> 这段区间的时候，如果可以想办法使图的规模变成和区间长度相关的一个变量的话，就可以解决这个问题了。</p>
<p>那么具体来讲如何设计算法呢？</p>
<p>假设我们正在构造 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 这段区间的最小生成树边集，并且我们已知它父亲最小生成树的边集。我们将在 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 这段区间中发生变化的边分别赋与 <span class="arithmatex"><span class="MathJax_Preview">+ \infty</span><script type="math/tex">+ \infty</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">-\infty</span><script type="math/tex">-\infty</script></span> 的边权，并各跑一边 kruskal，求出在最小生成树里的那些边。</p>
<p>对于一条边来讲：</p>
<ul>
<li>如果最小生成树里所有被修改的边权都被赋成了 <span class="arithmatex"><span class="MathJax_Preview">+\infty</span><script type="math/tex">+\infty</script></span>，而它未出现在树中，则证明它不可能出现在 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 这些询问的最小生成树当中。所以我们仅仅在 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 的边集中加入最小生成树的树边。</li>
<li>如果最小生成树里所有被修改的边权都被赋成了 <span class="arithmatex"><span class="MathJax_Preview">-\infty</span><script type="math/tex">-\infty</script></span>，而它未出现在树中，则证明它一定会出现 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 这段的区间的最小生成树当中。这样的话我们就可以使用并查集将这些边对应的点缩起来，并且将答案加上这些边的边权。</li>
</ul>
<p>这样我们就将 <span class="arithmatex"><span class="MathJax_Preview">(l,r)</span><script type="math/tex">(l,r)</script></span> 这段区间的边集构造出来了。用这些边求出来的最小生成树和直接求原图的最小生成树等价。</p>
<p>那么为什么我们的复杂度是对的呢？</p>
<p>首先，修改过的边一定会加进我们的边集，这些边的数目是 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 级别的。</p>
<p>接下来我们需要证明边集当中不会有过多的未被修改的边。我们只会加入所有边权取 <span class="arithmatex"><span class="MathJax_Preview">+\infty</span><script type="math/tex">+\infty</script></span> 最小生成树的树边，因此我们加入的边数目不会超过当前图的点数。</p>
<p>现在我们只需证明每递归一层图的点数是 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 级别的，就可以说明图的边数是 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 级别的了。</p>
<p>证明点数是 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 几倍就变得十分简单了。我们每次向下递归的时侯缩掉的边是在 <span class="arithmatex"><span class="MathJax_Preview">-\infty</span><script type="math/tex">-\infty</script></span> 生成树中出现的未被修改边，反过来想就是，我们割掉了出现在 <span class="arithmatex"><span class="MathJax_Preview">-\infty</span><script type="math/tex">-\infty</script></span> 生成树当中的所有的被修改边。显然我们最多割掉 <span class="arithmatex"><span class="MathJax_Preview">len</span><script type="math/tex">len</script></span> 条边，整张图最多分裂成 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 个连通块，这样的话新图点数就是 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 级别的了。所以我们就证明了每次我们用来跑 kruskal 的图都是 <span class="arithmatex"><span class="MathJax_Preview">O(len)</span><script type="math/tex">O(len)</script></span> 级别的了，从而每一层的时间复杂度都是 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span> 了。</p>
<p>时间复杂度是 <span class="arithmatex"><span class="MathJax_Preview">T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+ O(n\log n)=O(n\log^2n)</span><script type="math/tex">T(n)=T(\lfloor \frac{n}{2} \rfloor)+T(\lceil \frac{n}{2} \rceil)+ O(n\log n)=O(n\log^2n)</script></span>。</p>
<p>代码实现上可能会有一些难度。需要注意的是并查集不能使用路径压缩，否则就不支持回退操作了。执行缩点操作的时候也没有必要真的执行，而是每一层的 kruskal 都在上一层的并查集里直接做就可以了。</p>
</details>
<details class="示例代码">
<summary>示例代码</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
</details>
</details>
<h2 id="_8">拓展阅读<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://www.cs.princeton.edu/~danqic/papers/divide-and-conquer.pdf">从《Cash》谈一类分治算法的应用</a></li>
</ul>
<h2 id="_9">参考资料与注释<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<div class="footnote">
<hr />
<ol>
<li id="fn:ref1">
<p><a href="https://www.sohu.com/a/454907115_629135">陈丹琦：我希望女生能得到更多机会，男女生之间的 gap 会逐渐不存在的</a>&#160;<a class="footnote-backref" href="#fnref:ref1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                
                  
                
              
              
                 
 
 
<hr><blockquote class="page-copyright">
  <span><i class="md-icon">build</i>本页面最近更新：</span><span class="facts_modified"></span>，<a class="edit_history">更新历史</a><br>
  <span><i class="md-icon">edit</i>发现错误？想一起完善？ <a href="https://github.com/WWeiying/Learn-notes/edit/master/docs/misc/cdq-divide.md" title="编辑此页" class="page_edit_url">在 GitHub 上编辑此页！</a></span><br>
  <span><i class="md-icon">people</i>本页面贡献者：</span><span class="page_contributors">OI-wiki</span><br>
  <span><i class="md-icon">copyright</i>本页面的全部内容在 <strong><a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a></strong> 协议之条款下提供，附加条款亦可能应用</span>
</blockquote>


<h2 id="__comments" data-no-instant>评论</h2>
<form id="gitalk-form" onsubmit="return!1" data-no-instant>
<div id="gitalk-container" data-no-instant>
</div>
</form>
<link rel="stylesheet" href="../../assets/vendor/gitalk/gitalk.css">
<script src="../../assets/vendor/gitalk/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    id: 'Cdq divide',
    owner: 'WWeiying',
    repo: 'blogtalk',
    admin: ['WWeiying'],
    clientID: 'd3dc000b2047f49b2bd8',
    clientSecret: 'b20c67ecf9762b0de64976355994ac758d506962',
    distractionFreeMode: false,
    pagerDirection: 'first'
  })
  gitalk.render('gitalk-container')
</script>

              
            </article>
          </div>
        </div>
      </main>
      
        
<script>function scrollFunction(){20<document.body.scrollTop||20<document.documentElement.scrollTop?document.getElementById("myBtn").style.display="block":document.getElementById("myBtn").style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}window.onscroll=function(){scrollFunction()}</script>
<button onclick="topFunction()" id="myBtn" class="data-tip-left" data-tip="回到顶部">
  <svg class="Zi Zi--BackToTop data-tip-left" data-tip="回到顶部" fill="currentColor" viewBox="0 0 24 24" width="24" height="24">
    <path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path>
  </svg>
</button>
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2022 WWeiying
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
        <div id="miitbeian"></div>
      </div>
      
      <span style="float:right" class="build_date_utc"><a href="https://github.com/24OI/OI-wiki">最近更新：, 2022-04-29</a></span>
      <script>
        /* miitbeian */
        if (window.location.hostname == "oi-wiki.com") {
          document.getElementById("miitbeian").innerHTML = `<a href="http://beian.miit.gov.cn/">黑ICP备19005132号-2</a>`;
        }
        /* Easter Egg */
        console.log(`%c OI Wiki %c  %c`,"background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff","background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff","background:transparent");
        console.log('少年，恭喜你囍提彩蛋，我们在做一些 OI 相关的有趣的事情，如果您对此感兴趣，欢迎访问 https://join-us.oi-wiki.org');
      </script>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.411a9f9f.js"></script>
      <script>app.initialize({version:"1.2.4",url:{base:"../.."}}),"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js",{scope:"/"}).then(function(e){console.log("PWA Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("PWA Registration failed with "+e)})</script>
      
        <script src="../../_static/js/extra.js?v=16"></script>
      
        <script src="../../assets/vendor/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>