



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta http-equiv="x-dns-prefetch-control" content="on">
      <link rel="dns-prefetch" href="//oi-wiki.org">
      <link rel="dns-prefetch" href="//search.oi-wiki.org">
      <link rel="dns-prefetch" href="//api.github.com">
      <link rel="dns-prefetch" href="//www.google-analytics.com">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="OI Wiki 是一个编程竞赛知识整合站点，提供有趣又实用的编程竞赛知识以及其他有帮助的内容，帮助广大编程竞赛爱好者更快更深入地学习编程竞赛">
      
      
        <link rel="canonical" href="https://www.wweiying.top/math/poly/fft/">
      
      
        <meta name="author" content="A">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../../favicon.ico">
      <meta name="generator" content="mkdocs-1.2.4, mkdocs-material-4.4.2">
    
    
      
        <title>Fft - WWeiying's Learn-notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/application.6f7cfa25.css">
      
        <link rel="stylesheet" href="../../../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../../assets/javascripts/modernizr.27508f0e.js"></script>
    
    
      
        <style>@font-face{font-family:'Fira Sans';font-style:normal;font-weight:300;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:italic;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot);src:local('Fira Sans'),local('FiraSans-Italic'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:700;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Mono';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot);src:local('Fira Mono'),local('FiraMono-Normal'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.svg#FiraMono) format('svg')}body,input{font-family:"Fira Sans","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Fira Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../../assets/vendor/material-icons/iconfont/material-icons.css">
    
      <link rel="manifest" href="../../../manifest.webmanifest">
    
    
      <link rel="stylesheet" href="../../../_static/css/extra.css?v=13">
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-124485594-1", "auto")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#_1" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://www.wweiying.top/" title="WWeiying's Learn-notes" class="md-header-nav__button md-logo">
          
            <i class="md-icon">school</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              WWeiying's Learn-notes
            </span>
            <span class="md-header-nav__topic">
              
                Fft
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/WWeiying/Learn-notes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    WWeiying/Learn-notes
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

<nav class="md-tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../.." class="md-tabs__link">
          简介
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://www.wweiying.top/" title="WWeiying's Learn-notes" class="md-nav__button md-logo">
      
        <i class="md-icon">school</i>
      
    </a>
    WWeiying's Learn-notes
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/WWeiying/Learn-notes/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    WWeiying/Learn-notes
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      简介
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        简介
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../.." title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/about/" title="关于本项目" class="md-nav__link">
      关于本项目
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/htc/" title="如何参与" class="md-nav__link">
      如何参与
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/format/" title="格式手册" class="md-nav__link">
      格式手册
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/faq/" title="F.A.Q." class="md-nav__link">
      F.A.Q.
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/docker-deploy/" title="用 Docker 部署 OI Wiki" class="md-nav__link">
      用 Docker 部署 OI Wiki
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/mirrors/" title="镜像站列表" class="md-nav__link">
      镜像站列表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../intro/thanks/" title="致谢" class="md-nav__link">
      致谢
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    概述
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    多项式的表示
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    系数表示法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    点值表示法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    单位复根
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    定义
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    性质
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    快速傅里叶变换
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    位逆序置换
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    快速傅里叶逆变换
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    线性代数角度
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    单位复根周期性
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    方法一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    方法二
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    代码实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    快速数论变换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    参考文献
  </a>
  
</li>
      
      
      
      
      
        <li class="md-nav__item">
          <a href="#__comments" title="评论" class="md-nav__link md-nav__link--active">
            评论
          </a>
        </li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/WWeiying/Learn-notes/edit/master/docs/math/poly/fft.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>Fft</h1>
                
                <p>前置知识：<a href="../../complex/">复数</a>。</p>
<p>本文将介绍一种算法，它支持在 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span> 的时间内计算两个 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 度的多项式的乘法，比朴素的 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 算法更高效。由于两个整数的乘法也可以被当作多项式乘法，因此这个算法也可以用来加速大整数的乘法计算。</p>
<h2 id="_1">概述<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>离散傅里叶变换（Discrete Fourier Transform，缩写为 DFT），是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其 DTFT 的频域采样。</p>
<p>FFT 是一种高效实现 DFT 的算法，称为 <strong>快速傅立叶变换</strong>（Fast Fourier Transform，FFT）。它对傅里叶变换的理论并没有新的发现，但是对于在计算机系统或者说数字系统中应用离散傅立叶变换，可以说是进了一大步。快速数论变换 (NTT) 是快速傅里叶变换（FFT）在数论基础上的实现。</p>
<p>在 1965 年，Cooley 和 Tukey 发表了快速傅里叶变换算法。事实上 FFT 早在这之前就被发现过了，但是在当时现代计算机并未问世，人们没有意识到 FFT 的重要性。一些调查者认为 FFT 是由 Runge 和 König 在 1924 年发现的。但事实上高斯早在 1805 年就发明了这个算法，但一直没有发表。</p>
<h2 id="_2">多项式的表示<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="_3">系数表示法<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>系数表示法就是用一个多项式的各个项系数来表达这个多项式，即使用一个系数序列来表示多项式：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(x) = a_0+a_1x+a_2x^2+\cdots +a_{n}x^{n} \iff f(x) = \{a_0, a_1, \cdots,a_{n}\}
</div>
<script type="math/tex; mode=display">
f(x) = a_0+a_1x+a_2x^2+\cdots +a_{n}x^{n} \iff f(x) = \{a_0, a_1, \cdots,a_{n}\}
</script>
</div>
<h3 id="_4">点值表示法<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>点值表示法是把这个多项式看成一个函数，从上面选取 <span class="arithmatex"><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> 个点，从而利用这 <span class="arithmatex"><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> 个点来唯一地表示这个函数。</p>
<details class="note" open="open">
<summary>为什么用 <span class="arithmatex"><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> 个点就能唯一地表示这个函数</summary>
<p>法 I：想一下高斯消元法，两点确定一条直线。再来一个点，能确定这个直线中的另一个参数，那么也就是说 <span class="arithmatex"><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> 个点能确定 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 个参数（不考虑倍数点之类的没用点）。</p>
<p>法 II：假设原命题错误，则我们可以找到两个不相等又有 <span class="arithmatex"><span class="MathJax_Preview">n + 1</span><script type="math/tex">n + 1</script></span> 个交点的函数 <span class="arithmatex"><span class="MathJax_Preview">f(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n</span><script type="math/tex">f(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">g(x) = b_0 + b_1x + b_2x^2 + b_3x^3 + \cdots + b_nx^n</span><script type="math/tex">g(x) = b_0 + b_1x + b_2x^2 + b_3x^3 + \cdots + b_nx^n</script></span>。我们令 <span class="arithmatex"><span class="MathJax_Preview">h(x) = f(x) - g(x)</span><script type="math/tex">h(x) = f(x) - g(x)</script></span>，<strong><span class="arithmatex"><span class="MathJax_Preview">h(x)</span><script type="math/tex">h(x)</script></span> 显然是一个 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 次函数</strong>，且该函数与 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 轴有 <span class="arithmatex"><span class="MathJax_Preview">n + 1</span><script type="math/tex">n + 1</script></span> 个交点，即 <strong>有 <span class="arithmatex"><span class="MathJax_Preview">n + 1</span><script type="math/tex">n + 1</script></span> 个根</strong>。根据代数基本定理，<span class="arithmatex"><span class="MathJax_Preview">h(x)</span><script type="math/tex">h(x)</script></span> 是 <span class="arithmatex"><span class="MathJax_Preview">n + 1</span><script type="math/tex">n + 1</script></span> 次函数，矛盾。原命题成立。</p>
</details>
<p>设</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{array}{c}
f(x_0) = y_0 = a_0 + a_1x_0+a_2x_0^2+a_3x_0^3+ \cdots + a_nx_0^n\\
f(x_1) = y_1 = a_0 + a_1x_1+a_2x_1^2+a_3x_1^3+ \cdots + a_nx_1^n\\
f(x_2) = y_2 = a_0 + a_1x_2+a_2x_2^2+a_3x_2^3+ \cdots + a_nx_2^n\\
\vdots\\
f(x_{n}) = y_{n} = a_0 + a_1x_{n}+a_2x_{n}^2+a_3x_{n}^3+ \cdots + a_nx_{n}^n
\end{array}
</div>
<script type="math/tex; mode=display">
\begin{array}{c}
f(x_0) = y_0 = a_0 + a_1x_0+a_2x_0^2+a_3x_0^3+ \cdots + a_nx_0^n\\
f(x_1) = y_1 = a_0 + a_1x_1+a_2x_1^2+a_3x_1^3+ \cdots + a_nx_1^n\\
f(x_2) = y_2 = a_0 + a_1x_2+a_2x_2^2+a_3x_2^3+ \cdots + a_nx_2^n\\
\vdots\\
f(x_{n}) = y_{n} = a_0 + a_1x_{n}+a_2x_{n}^2+a_3x_{n}^3+ \cdots + a_nx_{n}^n
\end{array}
</script>
</div>
<p>那么用点值表示法表示 <span class="arithmatex"><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span> 如下</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(x) = a_0+a_1x+a_2x^2+\cdots +a_{n}x^{n} \iff f(x) = \{(x_0,y_0),(x_1,y_1), \cdots,(x_n,y_{n})\}
</div>
<script type="math/tex; mode=display">
f(x) = a_0+a_1x+a_2x^2+\cdots +a_{n}x^{n} \iff f(x) = \{(x_0,y_0),(x_1,y_1), \cdots,(x_n,y_{n})\}
</script>
</div>
<p>通俗地说，多项式由系数表示法转为点值表示法的过程，就是 DFT 的过程。相对地，把一个多项式的点值表示法转化为系数表示法的过程，就是 IDFT。而 FFT 就是通过取某些特殊的 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 的点值来加速 DFT 和 IDFT 的过程。</p>
<h2 id="_5">单位复根<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p>考虑这样一个问题：</p>
<p>DFT 是把多项式从系数表示转到了点值表示，那么我们把点值相乘之后，再还原成系数表示，就解决了我们的问题。上述过程如下：</p>
<p>假设我们 DFT 过程对于两个多项式选取的 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 序列相同，那么可以得到</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
f(x)&amp;={(x_0, f(x_0)), (x_1, f(x_1)), (x_2, f(x_2)), \cdots, (x_n, f(x_n))}\\
g(x)&amp;={(x_0, g(x_0)), (x_1, g(x_1)), (x_2, g(x_2)), \cdots, (x_n, g(x_n))}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&={(x_0, f(x_0)), (x_1, f(x_1)), (x_2, f(x_2)), \cdots, (x_n, f(x_n))}\\
g(x)&={(x_0, g(x_0)), (x_1, g(x_1)), (x_2, g(x_2)), \cdots, (x_n, g(x_n))}
\end{aligned}
</script>
</div>
<p>如果我们设 <span class="arithmatex"><span class="MathJax_Preview">F(x) = f(x) \cdot g(x)</span><script type="math/tex">F(x) = f(x) \cdot g(x)</script></span>，那么容易得到 <span class="arithmatex"><span class="MathJax_Preview">F(x)</span><script type="math/tex">F(x)</script></span> 的点值表达式：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
F(x) = \{(x_0, f(x_0)g(x_0)), (x_1, f(x_1)g(x_1)), (x_2, f(x_2)g(x_2)), \cdots, (x_n, f(x_n)g(x_n))\}
</div>
<script type="math/tex; mode=display">
F(x) = \{(x_0, f(x_0)g(x_0)), (x_1, f(x_1)g(x_1)), (x_2, f(x_2)g(x_2)), \cdots, (x_n, f(x_n)g(x_n))\}
</script>
</div>
<p>但是我们要的是系数表达式，接下来问题变成了从点值回到系数。如果我们带入到高斯消元法的方程组中去，会把复杂度变得非常高。光是计算 <span class="arithmatex"><span class="MathJax_Preview">x^i(0 \leq i \leq n)</span><script type="math/tex">x^i(0 \leq i \leq n)</script></span> 就是 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 项，这就已经 <span class="arithmatex"><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span> 了，更别说还要把 <span class="arithmatex"><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> 个方程进行消元……</p>
<p>因此我们不去计算 <span class="arithmatex"><span class="MathJax_Preview">x^i</span><script type="math/tex">x^i</script></span>。<span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> 的幂都很好算，但是仅仅有两个也不够，我们至少需要 <span class="arithmatex"><span class="MathJax_Preview">n+1</span><script type="math/tex">n+1</script></span> 个。利用我们刚学的长度为 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> 的虚数，这些数不管怎么乘长度都是 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>。我们需要的是 <span class="arithmatex"><span class="MathJax_Preview">\omega^k=1</span><script type="math/tex">\omega^k=1</script></span> 中的 <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>，容易想到 <span class="arithmatex"><span class="MathJax_Preview">-i</span><script type="math/tex">-i</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 是符合的。除此以外：</p>
<p><img alt="img" src="../images/fft2.jpg" /></p>
<p>观察上图，容易发现这是一个单位圆（圆心为原点，半径为 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>），单位圆上的向量模长均为 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>，根据复数的运算法则，两个复数相乘，在复平面上表示为两个向量模长相乘，辐角相加。因此两个模长为 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> 的向量相乘，得到的仍是模长为 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> 的向量，辐角为两个向量辐角的和。因此我们可以将 <span class="arithmatex"><span class="MathJax_Preview">\omega^k=1</span><script type="math/tex">\omega^k=1</script></span> 中的 <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span> 理解为复平面上的一个单位向量，满足它的辐角的 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 倍恰好是 <span class="arithmatex"><span class="MathJax_Preview">360^\circ</span><script type="math/tex">360^\circ</script></span>——即把圆周 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 等分的角。我们把符合以上条件的复数（复平面上的向量）称为复根，用 <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span> 表示。</p>
<h3 id="_6">定义<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>严谨地，我们称 <span class="arithmatex"><span class="MathJax_Preview">x^n=1</span><script type="math/tex">x^n=1</script></span> 在复数意义下的解是 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 次复根。显然，这样的解有 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 个，设 <span class="arithmatex"><span class="MathJax_Preview">\omega_n=e^{\frac{2\pi i}{n}}</span><script type="math/tex">\omega_n=e^{\frac{2\pi i}{n}}</script></span>，则 <span class="arithmatex"><span class="MathJax_Preview">x^n=1</span><script type="math/tex">x^n=1</script></span> 的解集表示为 <span class="arithmatex"><span class="MathJax_Preview">\{\omega_n^k\mid k=0,1\cdots,n-1\}</span><script type="math/tex">\{\omega_n^k\mid k=0,1\cdots,n-1\}</script></span>。我们称 <span class="arithmatex"><span class="MathJax_Preview">\omega_n</span><script type="math/tex">\omega_n</script></span> 是 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 次单位复根（the <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>-th root of unity）。根据复平面的知识，<span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 次单位复根是复平面把单位圆 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 等分的第一个角所对应的向量。其它复根均可以用单位复根的幂表示。</p>
<p>另一方面，根据欧拉公式，还可以得到 <span class="arithmatex"><span class="MathJax_Preview">\omega_n=e^{\frac{2\pi i}{n}}=\cos\left(\dfrac{2\pi}{n}\right)+i\cdot \sin\left(\dfrac{2\pi}{n}\right)</span><script type="math/tex">\omega_n=e^{\frac{2\pi i}{n}}=\cos\left(\dfrac{2\pi}{n}\right)+i\cdot \sin\left(\dfrac{2\pi}{n}\right)</script></span>。</p>
<p>举个例子，当 <span class="arithmatex"><span class="MathJax_Preview">n=4</span><script type="math/tex">n=4</script></span> 时，<span class="arithmatex"><span class="MathJax_Preview">\omega_n=i</span><script type="math/tex">\omega_n=i</script></span>，即 <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> 就是 <span class="arithmatex"><span class="MathJax_Preview">4</span><script type="math/tex">4</script></span> 次单位复根：</p>
<p><img alt="img" src="../images/fft3.png" /></p>
<p>当 <span class="arithmatex"><span class="MathJax_Preview">n = 4</span><script type="math/tex">n = 4</script></span> 的时候，相当于把单位圆等分 <span class="arithmatex"><span class="MathJax_Preview">n=4</span><script type="math/tex">n=4</script></span> 份。将每一份按照极角编号，那么我们只要知道 <span class="arithmatex"><span class="MathJax_Preview">\omega_4^1</span><script type="math/tex">\omega_4^1</script></span>（因为它的角度是相当于单位角度），就能知道 <span class="arithmatex"><span class="MathJax_Preview">\omega_4^0, \omega_4^1, \omega_4^2, \omega_4^3</span><script type="math/tex">\omega_4^0, \omega_4^1, \omega_4^2, \omega_4^3</script></span>。</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\omega_4^0</span><script type="math/tex">\omega_4^0</script></span> 恒等于 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>，<span class="arithmatex"><span class="MathJax_Preview">\omega_4^2</span><script type="math/tex">\omega_4^2</script></span> 的角度是 <span class="arithmatex"><span class="MathJax_Preview">\omega_4^1</span><script type="math/tex">\omega_4^1</script></span> 的两倍，所以 <span class="arithmatex"><span class="MathJax_Preview">\omega_4^2 = (\omega_4^1)^2 = i^2=-1</span><script type="math/tex">\omega_4^2 = (\omega_4^1)^2 = i^2=-1</script></span>，依次以此类推。</p>
<h3 id="_7">性质<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>单位复根有三个重要的性质。对于任意正整数 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 和整数 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\omega_n^n&amp;=1\\
\omega_n^k&amp;=\omega_{2n}^{2k}\\
\omega_{2n}^{k+n}&amp;=-\omega_{2n}^k\\
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\omega_n^n&=1\\
\omega_n^k&=\omega_{2n}^{2k}\\
\omega_{2n}^{k+n}&=-\omega_{2n}^k\\
\end{aligned}
</script>
</div>
<h2 id="_8">快速傅里叶变换<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h2>
<p>FFT 算法的基本思想是分治。就 DFT 来说，它分治地来求当 <span class="arithmatex"><span class="MathJax_Preview">x=\omega_n^k</span><script type="math/tex">x=\omega_n^k</script></span> 的时候 <span class="arithmatex"><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span> 的值。它的分治思想体现在将多项式分为奇次项和偶次项处理。</p>
<p>举个例子，对于一共 <span class="arithmatex"><span class="MathJax_Preview">8</span><script type="math/tex">8</script></span> 项的多项式</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(x) = a_0 + a_1x + a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7
</div>
<script type="math/tex; mode=display">
f(x) = a_0 + a_1x + a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6+a_7x^7
</script>
</div>
<p>按照次数的奇偶来分成两组，然后右边提出来一个 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span></p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
f(x) &amp;= (a_0+a_2x^2+a_4x^4+a_6x^6) + (a_1x+a_3x^3+a_5x^5+a_7x^7)\\
     &amp;= (a_0+a_2x^2+a_4x^4+a_6x^6) + x(a_1+a_3x^2+a_5x^4+a_7x^6)
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
f(x) &= (a_0+a_2x^2+a_4x^4+a_6x^6) + (a_1x+a_3x^3+a_5x^5+a_7x^7)\\
     &= (a_0+a_2x^2+a_4x^4+a_6x^6) + x(a_1+a_3x^2+a_5x^4+a_7x^6)
\end{aligned}
</script>
</div>
<p>分别用奇偶次次项数建立新的函数</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
G(x) &amp;= a_0+a_2x+a_4x^2+a_6x^3\\
H(x) &amp;= a_1+a_3x+a_5x^2+a_7x^3
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
G(x) &= a_0+a_2x+a_4x^2+a_6x^3\\
H(x) &= a_1+a_3x+a_5x^2+a_7x^3
\end{aligned}
</script>
</div>
<p>那么原来的 <span class="arithmatex"><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span> 用新函数表示为</p>
<div class="arithmatex">
<div class="MathJax_Preview">
f(x)=G\left(x^2\right) + x  \times  H\left(x^2\right)
</div>
<script type="math/tex; mode=display">
f(x)=G\left(x^2\right) + x  \times  H\left(x^2\right)
</script>
</div>
<p>利用单位复根的性质得到</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\operatorname{DFT}(f(\omega_n^k))
&amp;=\operatorname{DFT}(G((\omega_n^k)^2)) + \omega_n^k  \times \operatorname{DFT}(H((\omega_n^k)^2))\\
&amp;=\operatorname{DFT}(G(\omega_n^{2k})) + \omega_n^k  \times \operatorname{DFT}(H(\omega_n^{2k}))\\
&amp;=\operatorname{DFT}(G(\omega_{n/2}^k)) + \omega_n^k  \times \operatorname{DFT}(H(\omega_{n/2}^k))
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{DFT}(f(\omega_n^k))
&=\operatorname{DFT}(G((\omega_n^k)^2)) + \omega_n^k  \times \operatorname{DFT}(H((\omega_n^k)^2))\\
&=\operatorname{DFT}(G(\omega_n^{2k})) + \omega_n^k  \times \operatorname{DFT}(H(\omega_n^{2k}))\\
&=\operatorname{DFT}(G(\omega_{n/2}^k)) + \omega_n^k  \times \operatorname{DFT}(H(\omega_{n/2}^k))
\end{aligned}
</script>
</div>
<p>同理可得</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
\operatorname{DFT}(f(\omega_n^{k+n/2}))
&amp;=\operatorname{DFT}(G(\omega_n^{2k+n})) + \omega_n^{k+n/2}  \times \operatorname{DFT}(H(\omega_n^{2k+n}))\\
&amp;=\operatorname{DFT}(G(\omega_n^{2k})) - \omega_n^k  \times \operatorname{DFT}(H(\omega_n^{2k}))\\
&amp;=\operatorname{DFT}(G(\omega_{n/2}^k)) - \omega_n^k  \times \operatorname{DFT}(H(\omega_{n/2}^k))
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{DFT}(f(\omega_n^{k+n/2}))
&=\operatorname{DFT}(G(\omega_n^{2k+n})) + \omega_n^{k+n/2}  \times \operatorname{DFT}(H(\omega_n^{2k+n}))\\
&=\operatorname{DFT}(G(\omega_n^{2k})) - \omega_n^k  \times \operatorname{DFT}(H(\omega_n^{2k}))\\
&=\operatorname{DFT}(G(\omega_{n/2}^k)) - \omega_n^k  \times \operatorname{DFT}(H(\omega_{n/2}^k))
\end{aligned}
</script>
</div>
<p>因此我们求出了 <span class="arithmatex"><span class="MathJax_Preview">\operatorname{DFT}(G(\omega_{n/2}^k))</span><script type="math/tex">\operatorname{DFT}(G(\omega_{n/2}^k))</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">\operatorname{DFT}(H(\omega_{n/2}^k))</span><script type="math/tex">\operatorname{DFT}(H(\omega_{n/2}^k))</script></span> 后，就可以同时求出 <span class="arithmatex"><span class="MathJax_Preview">\operatorname{DFT}(f(\omega_n^k))</span><script type="math/tex">\operatorname{DFT}(f(\omega_n^k))</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">\operatorname{DFT}(f(\omega_n^{k+n/2}))</span><script type="math/tex">\operatorname{DFT}(f(\omega_n^{k+n/2}))</script></span>。于是对 <span class="arithmatex"><span class="MathJax_Preview">G</span><script type="math/tex">G</script></span> 和 <span class="arithmatex"><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> 分别递归 DFT 即可。</p>
<p>考虑到分治 DFT 能处理的多项式长度只能是 <span class="arithmatex"><span class="MathJax_Preview">2^m(m \in N^ \ast )</span><script type="math/tex">2^m(m \in N^ \ast )</script></span>，否则在分治的时候左右不一样长，右边就取不到系数了。所以要在第一次 DFT 之前就把序列向上补成长度为 <span class="arithmatex"><span class="MathJax_Preview">2^m(m \in N^\ast )</span><script type="math/tex">2^m(m \in N^\ast )</script></span>（高次系数补 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>）、最高项次数为 <span class="arithmatex"><span class="MathJax_Preview">2^m-1</span><script type="math/tex">2^m-1</script></span> 的多项式。</p>
<p>在代入值的时候，因为要代入 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 个不同值，所以我们代入 <span class="arithmatex"><span class="MathJax_Preview">\omega_n^0,\omega_n^1,\omega_n^2,\cdots, \omega_n^{n-1} (n=2^m(m \in N^ \ast ))</span><script type="math/tex">\omega_n^0,\omega_n^1,\omega_n^2,\cdots, \omega_n^{n-1} (n=2^m(m \in N^ \ast ))</script></span> 一共 <span class="arithmatex"><span class="MathJax_Preview">2^m</span><script type="math/tex">2^m</script></span> 个不同值。</p>
<p>代码实现方面，STL 提供了复数的模板，当然也可以手动实现。两者区别在于，使用 STL 的 <code>complex</code> 可以调用 <code>exp</code> 函数求出 <span class="arithmatex"><span class="MathJax_Preview">\omega_n</span><script type="math/tex">\omega_n</script></span>。但事实上使用欧拉公式得到的虚数来求 <span class="arithmatex"><span class="MathJax_Preview">\omega_n</span><script type="math/tex">\omega_n</script></span> 也是等价的。</p>
<details class="note" open="open">
<summary>递归版 FFT</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;complex&gt;</span><span class="cp"></span>

<span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Comp</span><span class="p">;</span><span class="w">  </span><span class="c1">// STL complex</span>

<span class="k">const</span><span class="w"> </span><span class="n">Comp</span><span class="w"> </span><span class="nf">I</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// i</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MAX_N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>

<span class="n">Comp</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">MAX_N</span><span class="p">];</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">DFT</span><span class="p">(</span><span class="n">Comp</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rev</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// rev=1,DFT; rev=-1,IDFT</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 偶数放左边，奇数放右边</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">Comp</span><span class="w"> </span><span class="o">*</span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">DFT</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">),</span><span class="w"> </span><span class="n">DFT</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">rev</span><span class="p">);</span><span class="w">  </span><span class="c1">// 递归 DFT</span>
<span class="w">  </span><span class="n">Comp</span><span class="w"> </span><span class="n">cur</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">step</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rev</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Comp step=exp(I*(2*M_PI/n*rev)); // 两个 step 定义是等价的</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cur</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">cur</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">step</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div></td></tr></table></div>
</details>
<p>时间复杂度 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span>。</p>
<h3 id="_9">位逆序置换<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>这个算法还可以从“分治”的角度继续优化。我们每一次都会把整个多项式的奇数次项和偶数次项系数分开，一直分到只剩下一个系数。但是，这个递归的过程需要更多的内存。因此，我们可以先“模仿递归”把这些系数在原数组中“拆分”，然后再“倍增”地去合并这些算出来的值。</p>
<p>以 <span class="arithmatex"><span class="MathJax_Preview">8</span><script type="math/tex">8</script></span> 项多项式为例，模拟拆分的过程：</p>
<ul>
<li>初始序列为 <span class="arithmatex"><span class="MathJax_Preview">\{x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7\}</span><script type="math/tex">\{x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7\}</script></span></li>
<li>一次二分之后 <span class="arithmatex"><span class="MathJax_Preview">\{x_0, x_2, x_4, x_6\},\{x_1, x_3, x_5, x_7 \}</span><script type="math/tex">\{x_0, x_2, x_4, x_6\},\{x_1, x_3, x_5, x_7 \}</script></span></li>
<li>两次二分之后 <span class="arithmatex"><span class="MathJax_Preview">\{x_0,x_4\} \{x_2, x_6\},\{x_1, x_5\},\{x_3, x_7 \}</span><script type="math/tex">\{x_0,x_4\} \{x_2, x_6\},\{x_1, x_5\},\{x_3, x_7 \}</script></span></li>
<li>三次二分之后 <span class="arithmatex"><span class="MathJax_Preview">\{x_0\}\{x_4\}\{x_2\}\{x_6\}\{x_1\}\{x_5\}\{x_3\}\{x_7 \}</span><script type="math/tex">\{x_0\}\{x_4\}\{x_2\}\{x_6\}\{x_1\}\{x_5\}\{x_3\}\{x_7 \}</script></span></li>
</ul>
<p>规律：其实就是原来的那个序列，每个数用二进制表示，然后把二进制翻转对称一下，就是最终那个位置的下标。比如 <span class="arithmatex"><span class="MathJax_Preview">x_1</span><script type="math/tex">x_1</script></span> 是 001，翻转是 100，也就是 4，而且最后那个位置确实是 4。我们称这个变换为位逆序置换（bit-reversal permutation，国内也称蝴蝶变换）。</p>
<p>根据它的定义，我们可以在 <span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span> 的时间内求出每个数变换后的结果：</p>
<details class="note" open="open">
<summary>位逆序变换实现（<span class="arithmatex"><span class="MathJax_Preview">O(n\log n)</span><script type="math/tex">O(n\log n)</script></span>）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * 进行 FFT 和 IFFT 前的反置变换</span>
<span class="cm"> * 位置 i 和 i 的二进制反转后的位置互换</span>
<span class="cm"> *len 必须为 2 的幂</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">change</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">y</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 交换互为小标反转的元素，i&lt;j 保证交换一次</span>
<span class="w">    </span><span class="c1">// i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的</span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div></td></tr></table></div>
</details>
<p>实际上，位逆序变换可以 <span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span> 从小到大递推实现，设 <span class="arithmatex"><span class="MathJax_Preview">len=2^k</span><script type="math/tex">len=2^k</script></span>，其中 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 表示二进制数的长度，设 <span class="arithmatex"><span class="MathJax_Preview">R(x)</span><script type="math/tex">R(x)</script></span> 表示长度为 <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> 的二进制数 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 翻转后的数（高位补 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>）。我们要求的是 <span class="arithmatex"><span class="MathJax_Preview">R(0),R(1),\cdots,R(n-1)</span><script type="math/tex">R(0),R(1),\cdots,R(n-1)</script></span>。</p>
<p>首先 <span class="arithmatex"><span class="MathJax_Preview">R(0)=0</span><script type="math/tex">R(0)=0</script></span>。</p>
<p>我们从小到大求 <span class="arithmatex"><span class="MathJax_Preview">R(x)</span><script type="math/tex">R(x)</script></span>。因此在求 <span class="arithmatex"><span class="MathJax_Preview">R(x)</span><script type="math/tex">R(x)</script></span> 时，<span class="arithmatex"><span class="MathJax_Preview">R\left(\left\lfloor \dfrac{x}{2} \right\rfloor\right)</span><script type="math/tex">R\left(\left\lfloor \dfrac{x}{2} \right\rfloor\right)</script></span> 的值是已知的。因此我们把 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 右移一位（除以 <span class="arithmatex"><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span>），然后取反，再右移一位，就得到了 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>  <strong>除了（二进制）个位</strong> 之外其它位的翻转结果。</p>
<p>考虑个位的翻转结果：如果个位是 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>，翻转之后最高位就是 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>。如果个位是 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>，则翻转后最高位是 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>，因此还要加上 <span class="arithmatex"><span class="MathJax_Preview">\dfrac{len}{2}=2^{k-1}</span><script type="math/tex">\dfrac{len}{2}=2^{k-1}</script></span>。综上</p>
<div class="arithmatex">
<div class="MathJax_Preview">
R(x)=\left\lfloor \frac{R\left(\left\lfloor \frac{x}{2} \right\rfloor\right)}{2} \right\rfloor + (x\bmod 2)\times \frac{len}{2}
</div>
<script type="math/tex; mode=display">
R(x)=\left\lfloor \frac{R\left(\left\lfloor \frac{x}{2} \right\rfloor\right)}{2} \right\rfloor + (x\bmod 2)\times \frac{len}{2}
</script>
</div>
<p>举个例子：设 <span class="arithmatex"><span class="MathJax_Preview">k=5</span><script type="math/tex">k=5</script></span>，<span class="arithmatex"><span class="MathJax_Preview">len=(100000)_2</span><script type="math/tex">len=(100000)_2</script></span>。为了翻转 <span class="arithmatex"><span class="MathJax_Preview">(11001)_2</span><script type="math/tex">(11001)_2</script></span>：</p>
<ol>
<li>考虑 <span class="arithmatex"><span class="MathJax_Preview">(1100)_2</span><script type="math/tex">(1100)_2</script></span>，我们知道 <span class="arithmatex"><span class="MathJax_Preview">R((1100)_2)=R((01100)_2)=(00110)_2</span><script type="math/tex">R((1100)_2)=R((01100)_2)=(00110)_2</script></span>，再右移一位就得到了 <span class="arithmatex"><span class="MathJax_Preview">(00011)_2</span><script type="math/tex">(00011)_2</script></span>。</li>
<li>考虑个位，如果是 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>，它就要翻转到数的最高位，即翻转数加上 <span class="arithmatex"><span class="MathJax_Preview">(10000)_2=2^{k-1}</span><script type="math/tex">(10000)_2=2^{k-1}</script></span>，如果是 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> 则不用更改。</li>
</ol>
<details class="note" open="open">
<summary>位逆序变换实现（<span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// 同样需要保证 len 是 2 的幂</span>
<span class="c1">// 记 rev[i] 为 i 翻转后的值</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">change</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">y</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 如果最后一位是 1，则翻转成 len/2</span>
<span class="w">      </span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 保证每对数只翻转一次</span>
<span class="w">      </span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">rev</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div></td></tr></table></div>
</details>
<h2 id="_10">快速傅里叶逆变换<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h2>
<p>傅里叶逆变换可以用傅里叶变换表示。对此我们有两种理解方式。</p>
<h3 id="_11">线性代数角度<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<p>IDFT（傅里叶反变换）的作用，是把目标多项式的点值形式转换成系数形式。而 DFT 本身是个线性变换，可以理解为将目标多项式当作向量，左乘一个矩阵得到变换后的向量，以模拟把单位复根代入多项式的过程：</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{bmatrix}y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1} \end{bmatrix}
=
\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_n^1 &amp; \omega_n^2 &amp; \omega_n^3 &amp; \cdots &amp; \omega_n^{n-1} \\
1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \omega_n^6 &amp; \cdots &amp; \omega_n^{2(n-1)} \\
1 &amp; \omega_n^3 &amp; \omega_n^6 &amp; \omega_n^9 &amp; \cdots &amp; \omega_n^{3(n-1)} \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \omega_n^{3(n-1)} &amp; \cdots &amp; \omega_n^{(n-1)^2} \end{bmatrix}
\begin{bmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1} \end{bmatrix}
</div>
<script type="math/tex; mode=display">
\begin{bmatrix}y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1} \end{bmatrix}
=
\begin{bmatrix}1 & 1 & 1 & 1 & \cdots & 1 \\
1 & \omega_n^1 & \omega_n^2 & \omega_n^3 & \cdots & \omega_n^{n-1} \\
1 & \omega_n^2 & \omega_n^4 & \omega_n^6 & \cdots & \omega_n^{2(n-1)} \\
1 & \omega_n^3 & \omega_n^6 & \omega_n^9 & \cdots & \omega_n^{3(n-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega_n^{n-1} & \omega_n^{2(n-1)} & \omega_n^{3(n-1)} & \cdots & \omega_n^{(n-1)^2} \end{bmatrix}
\begin{bmatrix} a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1} \end{bmatrix}
</script>
</div>
<p>现在我们已经得到最左边的结果了，中间的 <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> 值在目标多项式的点值表示中也是一一对应的，所以，根据矩阵的基础知识，我们只要在式子两边左乘中间那个大矩阵的逆矩阵就行了。由于这个矩阵的元素非常特殊，它的逆矩阵也有特殊的性质，就是每一项取倒数，再除以 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>，就能得到它的逆矩阵。</p>
<p>为了使计算的结果为原来的倒数，根据单位复根的性质并结合欧拉公式，可以得到</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\frac{1}{\omega_k}=\omega_k^{-1}=e^{-\frac{2\pi i}{k}}=\cos\left(\frac{2\pi}{k}\right)+i\cdot \sin\left(-\frac{2\pi}{k}\right)
</div>
<script type="math/tex; mode=display">
\frac{1}{\omega_k}=\omega_k^{-1}=e^{-\frac{2\pi i}{k}}=\cos\left(\frac{2\pi}{k}\right)+i\cdot \sin\left(-\frac{2\pi}{k}\right)
</script>
</div>
<p>因此我们可以尝试着把单位根 <span class="arithmatex"><span class="MathJax_Preview">\omega_k</span><script type="math/tex">\omega_k</script></span> 取成 <span class="arithmatex"><span class="MathJax_Preview">e^{-\frac{2\pi i}{k}}</span><script type="math/tex">e^{-\frac{2\pi i}{k}}</script></span>，这样我们的计算结果就会变成原来的倒数，而其它的操作过程与 DFT 是完全相同的。我们可以定义一个函数，在里面加一个参数 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> 或者是 <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span>，然后把它乘到 <span class="arithmatex"><span class="MathJax_Preview">\pi</span><script type="math/tex">\pi</script></span> 上。传入 <span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> 就是 DFT，传入 <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> 就是 IDFT。</p>
<h3 id="_12">单位复根周期性<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>利用单位复根的周期性同样可以理解 IDFT 与 DFT 之间的关系。</p>
<p>考虑原本的多项式是 <span class="arithmatex"><span class="MathJax_Preview">f(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}=\sum_{i=0}^{n-1}a_ix^i</span><script type="math/tex">f(x)=a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}=\sum_{i=0}^{n-1}a_ix^i</script></span>。而 IDFT 就是把你的点值表示还原为系数表示。</p>
<p>考虑 <strong>构造法</strong>。我们已知 <span class="arithmatex"><span class="MathJax_Preview">y_i=f\left( \omega_n^i \right),i\in\{0,1,\cdots,n-1\}</span><script type="math/tex">y_i=f\left( \omega_n^i \right),i\in\{0,1,\cdots,n-1\}</script></span>，求 <span class="arithmatex"><span class="MathJax_Preview">\{a_0,a_1,\cdots,a_{n-1}\}</span><script type="math/tex">\{a_0,a_1,\cdots,a_{n-1}\}</script></span>。构造多项式如下</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A(x)=\sum_{i=0}^{n-1}y_ix^i
</div>
<script type="math/tex; mode=display">
A(x)=\sum_{i=0}^{n-1}y_ix^i
</script>
</div>
<p>相当于把 <span class="arithmatex"><span class="MathJax_Preview">\{y_0,y_1,y_2,\cdots,y_{n-1}\}</span><script type="math/tex">\{y_0,y_1,y_2,\cdots,y_{n-1}\}</script></span> 当做多项式 <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> 的系数表示法。</p>
<p>这时我们有两种推导方式，这对应了两种实现方法。</p>
<h4 id="_13">方法一<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p>设 <span class="arithmatex"><span class="MathJax_Preview">b_i=\omega_n^{-i}</span><script type="math/tex">b_i=\omega_n^{-i}</script></span>，则多项式 <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> 在 <span class="arithmatex"><span class="MathJax_Preview">x=b_0,b_1,\cdots,b_{n-1}</span><script type="math/tex">x=b_0,b_1,\cdots,b_{n-1}</script></span> 处的点值表示法为 <span class="arithmatex"><span class="MathJax_Preview">\left\{ A(b_0),A(b_1),\cdots,A(b_{n-1}) \right\}</span><script type="math/tex">\left\{ A(b_0),A(b_1),\cdots,A(b_{n-1}) \right\}</script></span>。</p>
<p>对 <span class="arithmatex"><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span> 的定义式做一下变换，可以将 <span class="arithmatex"><span class="MathJax_Preview">A(b_k)</span><script type="math/tex">A(b_k)</script></span> 表示为</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
A(b_k)&amp;=\sum_{i=0}^{n-1}f(\omega_n^i)\omega_n^{-ik}=\sum_{i=0}^{n-1}\omega_n^{-ik}\sum_{j=0}^{n-1}a_j(\omega_n^i)^{j}\\
&amp;=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\omega_n^{i(j-k)}=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}\left(\omega_n^{j-k}\right)^i\\
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
A(b_k)&=\sum_{i=0}^{n-1}f(\omega_n^i)\omega_n^{-ik}=\sum_{i=0}^{n-1}\omega_n^{-ik}\sum_{j=0}^{n-1}a_j(\omega_n^i)^{j}\\
&=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j\omega_n^{i(j-k)}=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}\left(\omega_n^{j-k}\right)^i\\
\end{aligned}
</script>
</div>
<p>记 <span class="arithmatex"><span class="MathJax_Preview">S\left(\omega_n^a\right)=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i</span><script type="math/tex">S\left(\omega_n^a\right)=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i</script></span>。</p>
<p>当 <span class="arithmatex"><span class="MathJax_Preview">a=0 \pmod{n}</span><script type="math/tex">a=0 \pmod{n}</script></span> 时，<span class="arithmatex"><span class="MathJax_Preview">S\left(\omega_n^a\right)=n</span><script type="math/tex">S\left(\omega_n^a\right)=n</script></span>。</p>
<p>当 <span class="arithmatex"><span class="MathJax_Preview">a\neq 0 \pmod{n}</span><script type="math/tex">a\neq 0 \pmod{n}</script></span> 时，我们错位相减</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
S\left(\omega_n^a\right)&amp;=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i\\
\omega_n^a S\left(\omega_n^a\right)&amp;=\sum_{i=1}^{n}\left(\omega_n^a\right)^i\\
S\left(\omega_n^a\right)&amp;=\frac{\left(\omega_n^a\right)^n-\left(\omega_n^a\right)^0}{\omega_n^a-1}=0\\
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
S\left(\omega_n^a\right)&=\sum_{i=0}^{n-1}\left(\omega_n^a\right)^i\\
\omega_n^a S\left(\omega_n^a\right)&=\sum_{i=1}^{n}\left(\omega_n^a\right)^i\\
S\left(\omega_n^a\right)&=\frac{\left(\omega_n^a\right)^n-\left(\omega_n^a\right)^0}{\omega_n^a-1}=0\\
\end{aligned}
</script>
</div>
<p>也就是说</p>
<div class="arithmatex">
<div class="MathJax_Preview">
S\left(\omega_n^a\right)=
\left\{\begin{aligned}
n,a=0\\
0,a\neq 0
\end{aligned}\right.
</div>
<script type="math/tex; mode=display">
S\left(\omega_n^a\right)=
\left\{\begin{aligned}
n,a=0\\
0,a\neq 0
\end{aligned}\right.
</script>
</div>
<p>那么代回原式</p>
<div class="arithmatex">
<div class="MathJax_Preview">
A(b_k)=\sum_{j=0}^{n-1}a_jS\left(\omega_n^{j-k}\right)=a_k\cdot n
</div>
<script type="math/tex; mode=display">
A(b_k)=\sum_{j=0}^{n-1}a_jS\left(\omega_n^{j-k}\right)=a_k\cdot n
</script>
</div>
<p>也就是说给定点 <span class="arithmatex"><span class="MathJax_Preview">b_i=\omega_n^{-i}</span><script type="math/tex">b_i=\omega_n^{-i}</script></span>，则 <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> 的点值表示法为</p>
<div class="arithmatex">
<div class="MathJax_Preview">
\begin{aligned}
&amp;\left\{ (b_0,A(b_0)),(b_1,A(b_1)),\cdots,(b_{n-1},A(b_{n-1})) \right\}\\
=&amp;\left\{ (b_0,a_0\cdot n),(b_1,a_1\cdot n),\cdots,(b_{n-1},a_{n-1}\cdot n) \right\}
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
&\left\{ (b_0,A(b_0)),(b_1,A(b_1)),\cdots,(b_{n-1},A(b_{n-1})) \right\}\\
=&\left\{ (b_0,a_0\cdot n),(b_1,a_1\cdot n),\cdots,(b_{n-1},a_{n-1}\cdot n) \right\}
\end{aligned}
</script>
</div>
<p>综上所述，我们取单位根为其倒数，对 <span class="arithmatex"><span class="MathJax_Preview">\{y_0,y_1,y_2,\cdots,y_{n-1}\}</span><script type="math/tex">\{y_0,y_1,y_2,\cdots,y_{n-1}\}</script></span> 跑一遍 FFT，然后除以 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> 即可得到 <span class="arithmatex"><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span> 的系数表示。</p>
<h4 id="_14">方法二<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>我们直接将 <span class="arithmatex"><span class="MathJax_Preview">\omega_n^i</span><script type="math/tex">\omega_n^i</script></span> 代入 <span class="arithmatex"><span class="MathJax_Preview">A(x)</span><script type="math/tex">A(x)</script></span>。</p>
<p>推导的过程与方法一大同小异，最终我们得到 <span class="arithmatex"><span class="MathJax_Preview">A(\omega_n^k) = \sum_{j=0}^{n-1}a_jS\left(\omega_n^{j+k}\right)</span><script type="math/tex">A(\omega_n^k) = \sum_{j=0}^{n-1}a_jS\left(\omega_n^{j+k}\right)</script></span>。</p>
<p>当且仅当 <span class="arithmatex"><span class="MathJax_Preview">j+k=0 \pmod{n}</span><script type="math/tex">j+k=0 \pmod{n}</script></span> 时有 <span class="arithmatex"><span class="MathJax_Preview">S\left(\omega_n^{j+k}\right) = n</span><script type="math/tex">S\left(\omega_n^{j+k}\right) = n</script></span>，否则为 <span class="arithmatex"><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>。因此 <span class="arithmatex"><span class="MathJax_Preview">A(\omega_n^k) = a_{n-k}\cdot n</span><script type="math/tex">A(\omega_n^k) = a_{n-k}\cdot n</script></span>。</p>
<p>这意味着我们将 <span class="arithmatex"><span class="MathJax_Preview">\{y_0,y_1,y_2,\cdots,y_{n-1}\}</span><script type="math/tex">\{y_0,y_1,y_2,\cdots,y_{n-1}\}</script></span> 做 DFT 变换后除以 <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>，再反转后 <span class="arithmatex"><span class="MathJax_Preview">n - 1</span><script type="math/tex">n - 1</script></span> 个元素，同样可以还原 <span class="arithmatex"><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span> 的系数表示。</p>
<h3 id="_15">代码实现<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<p>所以我们 FFT 函数可以集 DFT 和 IDFT 于一身。代码实现如下：</p>
<details class="note" open="open">
<summary>非递归版 FFT（对应方法一）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * 做 FFT</span>
<span class="cm"> * len 必须是 2^k 形式</span>
<span class="cm"> * on == 1 时是 DFT，on == -1 时是 IDFT</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">fft</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">y</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">on</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">change</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                  </span><span class="c1">// 模拟合并过程</span>
<span class="w">    </span><span class="n">Complex</span><span class="w"> </span><span class="n">wn</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">h</span><span class="p">),</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">on</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">h</span><span class="p">));</span><span class="w">  </span><span class="c1">// 计算当前单位复根</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Complex</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 计算当前单位复根</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">  </span><span class="c1">// 这就是把两部分分治的结果加起来</span>
<span class="w">        </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 后半个 “step” 中的ω一定和 “前半个” 中的成相反数</span>
<span class="w">        </span><span class="c1">// “红圈”上的点转一整圈“转回来”，转半圈正好转成相反数</span>
<span class="w">        </span><span class="c1">// 一个数相反数的平方与这个数自身的平方相等</span>
<span class="w">        </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">wn</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">on</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div></td></tr></table></div>
</details>
<details class="note" open="open">
<summary>非递归版 FFT（对应方法二）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * 做 FFT</span>
<span class="cm"> * len 必须是 2^k 形式</span>
<span class="cm"> * on == 1 时是 DFT，on == -1 时是 IDFT</span>
<span class="cm"> */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">fft</span><span class="p">(</span><span class="n">Complex</span><span class="w"> </span><span class="n">y</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">on</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">change</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">             </span><span class="c1">// 模拟合并过程</span>
<span class="w">    </span><span class="n">Complex</span><span class="w"> </span><span class="n">wn</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">h</span><span class="p">),</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">h</span><span class="p">));</span><span class="w">  </span><span class="c1">// 计算当前单位复根</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">Complex</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 计算当前单位复根</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">Complex</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">  </span><span class="c1">// 这就是把两部分分治的结果加起来</span>
<span class="w">        </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// 后半个 “step” 中的ω一定和 “前半个” 中的成相反数</span>
<span class="w">        </span><span class="c1">// “红圈”上的点转一整圈“转回来”，转半圈正好转成相反数</span>
<span class="w">        </span><span class="c1">// 一个数相反数的平方与这个数自身的平方相等</span>
<span class="w">        </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">wn</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">on</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">reverse</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div></td></tr></table></div>
</details>
<details>
<summary><a href="https://www.luogu.com.cn/problem/P1919">FFT 模板</a></summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
</details>
<details>
<summary>FFT 模板 三次转两次优化（ <a href="https://www.luogu.com.cn/problem/P1919">「Luogu P1919」【模板】A*B Problem 升级版 </a> ）</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
</details>
<h2 id="_16">快速数论变换<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h2>
<p>若要计算的多项式系数是别的具有特殊意义的整数，那么 FFT 全部用浮点数运算，从时间上比整数运算慢，且只能用 long double 类型。</p>
<p>要应用数论变化从而避开浮点运算精度问题，参见 <a href="/math/poly/ntt">快速数论变换</a>。</p>
<h2 id="_17">参考文献<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/41867199">桃酱的算法笔记</a>.</li>
</ol>
                
                  
                
              
              
                 
 
   
<hr><blockquote class="page-copyright">
  <span><i class="md-icon">build</i>本页面最近更新：</span><span class="facts_modified"></span>，<a class="edit_history">更新历史</a><br>
  <span><i class="md-icon">edit</i>发现错误？想一起完善？ <a href="https://github.com/WWeiying/Learn-notes/edit/master/docs/math/poly/fft.md" title="编辑此页" class="page_edit_url">在 GitHub 上编辑此页！</a></span><br>
  <span><i class="md-icon">people</i>本页面贡献者：</span><span class="page_contributors">AndrewWayne, GavinZhengOI, ChungZH, henryrabbit, Xeonacid, sshwy, Yukimaikoriya, EarthMessenger</span><br>
  <span><i class="md-icon">copyright</i>本页面的全部内容在 <strong><a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a></strong> 协议之条款下提供，附加条款亦可能应用</span>
</blockquote>


<h2 id="__comments" data-no-instant>评论</h2>
<form id="gitalk-form" onsubmit="return!1" data-no-instant>
<div id="gitalk-container" data-no-instant>
</div>
</form>
<link rel="stylesheet" href="../../../assets/vendor/gitalk/gitalk.css">
<script src="../../../assets/vendor/gitalk/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    id: 'Fft',
    owner: 'OI-wiki',
    repo: 'gitment',
    admin: ['Ir1d', 'cjsoft', 'TrisolarisHD', 'Xeonacid', 'sshwy', 'Enter-tainer', 'StudyingFather'],
    clientID: 'd6a911c8fba0194626d4',
    clientSecret: '867ec7e13cc99b420bd147cbb62d5cfec271ba81',
    distractionFreeMode: false,
    pagerDirection: 'first'
  })
  gitalk.render('gitalk-container')
</script>

              
            </article>
          </div>
        </div>
      </main>
      
        
<script>function scrollFunction(){20<document.body.scrollTop||20<document.documentElement.scrollTop?document.getElementById("myBtn").style.display="block":document.getElementById("myBtn").style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}window.onscroll=function(){scrollFunction()}</script>
<button onclick="topFunction()" id="myBtn" class="data-tip-left" data-tip="回到顶部">
  <svg class="Zi Zi--BackToTop data-tip-left" data-tip="回到顶部" fill="currentColor" viewBox="0 0 24 24" width="24" height="24">
    <path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path>
  </svg>
</button>
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2022 WWeiying
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
        <div id="miitbeian"></div>
      </div>
      
      <span style="float:right" class="build_date_utc"><a href="https://github.com/24OI/OI-wiki">最近更新：, 2022-04-29</a></span>
      <script>
        /* miitbeian */
        if (window.location.hostname == "oi-wiki.com") {
          document.getElementById("miitbeian").innerHTML = `<a href="http://beian.miit.gov.cn/">黑ICP备19005132号-2</a>`;
        }
        /* Easter Egg */
        console.log(`%c OI Wiki %c  %c`,"background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff","background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff","background:transparent");
        console.log('少年，恭喜你囍提彩蛋，我们在做一些 OI 相关的有趣的事情，如果您对此感兴趣，欢迎访问 https://join-us.oi-wiki.org');
      </script>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/application.411a9f9f.js"></script>
      <script>app.initialize({version:"1.2.4",url:{base:"../../.."}}),"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js",{scope:"/"}).then(function(e){console.log("PWA Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("PWA Registration failed with "+e)})</script>
      
        <script src="../../../_static/js/extra.js?v=16"></script>
      
        <script src="../../../assets/vendor/mathjax/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>